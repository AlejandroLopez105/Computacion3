# -*- coding: utf-8 -*-
"""Vectorización

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/188FKjdNFRZdP3h5JPfHVx7dpI6qjmxKn

###  Vectorización de matrices
"""

import time
import  numpy as np
import matplotlib.pyplot as plt

class Matrix:
    def __init__(self, f, c, M,M_2):
        self.f = f
        self.c = c
        self.M = M
        self.M_2 = M_2
######################################SUMAS##################################################
    def suma(self):
        start = time.time()
        z = np.zeros_like(self.M)
        for i in range(len(self.M)):
            for j in range(len(self.M[0])):
                z[i][j] = self.M[i][j] + self.M_2[i][j]
        end = time.time()
        print("Total matrix sum time: ", (end-start)*1000, "ms")
        return z
    
    def sumaNumpy(self):
        start = time.time()
        z = np.zeros_like(self.M)
        z = self.M + self.M_2
        end = time.time()
        #print("Total matrix Numpy sum time: ", (end-start)*1000, "ms")
        return z

    def vectorizedSum(self, V,V_2):
        start = time.time()
        Z = np.zeros(self.f*self.c)
        for i in range (self.c*self.f):
            Z[i] = V[i] + V_2[i]
        end = time.time()
        print("Total vectorized matrix sum time: ", (end-start)*1000, "ms")

    def vectorizedSumNumpy(self, V,V_2):
        start = time.time()
        Z = V + V_2
        end = time.time()
        #print("Total vectorized matrix Numpy sum time: ", (end-start)*1000, "ms")
    def plotSpeedUp(self, x, y):
      plt.title("SpeedUp")
      plt.xlabel("N, the dimension of the matrix is given by NxN")
      plt.ylabel("Execution Time")
      plt.plot(x,y)
    def saveFigure(self, title, quality):
        plt.savefig(title, dpi=quality, bbox_inches='tight')
######################################RESTAS##################################################
    def subtraction(self):
        # Definir una matriz de las mismas dimensiones de A
        # Verificar que las matrices sean iguales
        start = time.time()
        if (len(self.M) == len(self.M_2) and len(self.M[0] == len(self.M_2[0]))):
            C = np.zeros_like(self.M);
            for i in range(len(self.M)):
                for j in range(len(self.M[0])):
                    C[i][j] = self.M[i][j] - self.M_2[i][j]
        end = time.time()
        print("Total matrix subtraction time: ", (end-start)*1000, "ms")
    def vectorizedSub(self, V,V_2):
        start = time.time()
        Z = np.zeros(self.f*self.c)
        for i in range (self.c*self.f):
            Z[i] = V[i] - V_2[i]
        end = time.time()
        print("Total vectorized matrix subtraction time: ", (end-start)*1000, "ms")
######################################Multiplicaciones#########################################
    def multiplicaciónMatrices(self):
        start = time.time()
        if(len(self.M_2[0]) == len(self.M)):
            z = np.zeros_like(self.M)
            for i in range(len(self.M_2)):
              for j in range(len(self.M[0])):
                for k in range(len(self.M)):
                  z[i][j]+= self.M[i][k]*self.M_2[k][j]
        else: 
            print("No es posible realizar la multiplicación matricial")
        end = time.time()
        time_mult_convencional = (end-start)*1000
        return z, time_mult_convencional
    def vectorizedMult(self, V,V_2):
      start = time.time()
      if(len(V)==len(V_2)):
        z = np.zeros(len(V))
        a=0
        b=0
        for i in range(len(V_2)):
          for j in range(self.c):
            z[i] += V[j+a]*V_2[b+j*self.c]
            if((j+1)%self.c == 0):
              b+=1
          if((i+1)%self.c==0):
            a+=self.c
            b=0
      else:
        print("No es posible realizar la multiplicación")
      end = time.time()
      time_mult_vector = (end-start)*1000
      return z, time_mult_vector

def main():
    f = 100
    indice = 0
    rango = 10
    f_vec =np.zeros(rango)
    times_convencional = np.zeros(rango)
    times_vectorizada = np.zeros(rango)
    SpeedUp = np.zeros(rango)
    while(f<=1000):
      c = f
      f_vec[indice] = f
      M = np.random.randint(10, size= (f,c))
      M_2 = np.random.randint(10,size=(f,c))
      # Definición manual de vector 
      V1 = np.zeros(f*c)
      for i in range(len(M)):
          for j in range(len(M[0])):
              V1[j + i * len(M[0])] = M[i][j]
      #print(M)
      #print(M_2)
      # Vectorización automática
      V = M.reshape(f*c)
      V_2 = M_2.reshape(f*c)
      objM = Matrix(f, c, M,M_2)
      #objM.suma()
      #objM.sumaNumpy()
      #objM.vectorizedSum(V,V_2)
      #objM.vectorizedSumNumpy(V,V_2)
      mult_convencional, times_convencional[indice] = objM.multiplicaciónMatrices()
      mult_vectorizada,times_vectorizada[indice] = objM.vectorizedMult(V,V_2)
      SpeedUp[indice] = times_convencional[indice]/times_vectorizada[indice]
      #print("Multiplicación convencional: \n",mult_convencional)
      #print("Multiplicación vectorizada:\n",mult_vectorizada)
      f+=100
      indice+=1

    print("Tiempos, multiplicación convencional: \n",times_convencional)
    print("Tiempos, multiplicación vectorizada: \n", times_vectorizada)
    print("SpeedUP: \n", SpeedUp)
    objM.plotSpeedUp(f_vec, SpeedUp)
    objM.saveFigure("Vectorización", 300)
if __name__ == "__main__":
    main()