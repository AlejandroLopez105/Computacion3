# -*- coding: utf-8 -*-
"""Operaciones con matrices dispersas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19Pe3OOYmiSQe_5Fl30aao3wzw4svY_75
"""

import time
import  numpy as np
import matplotlib.pyplot as plt
import random
import copy 
class Matrix:
    def __init__(self, f, c, M,M_2):
        self.f = f
        self.c = c
        self.M = M
        self.M_2 = M_2
######################################SUMAS##################################################
    def suma(self):
        start = time.time()
        z = np.zeros_like(self.M)
        for i in range(len(self.M)):
            for j in range(len(self.M[0])):
                z[i][j] = self.M[i][j] + self.M_2[i][j]
        end = time.time()
        #print("Total matrix sum time: ", (end-start)*1000, "ms")
        return z, (end-start)*1000
    
    def sumaNumpy(self):
        start = time.time()
        z = np.zeros_like(self.M)
        z = self.M + self.M_2
        end = time.time()
        #print("Total matrix Numpy sum time: ", (end-start)*1000, "ms")
        return z

    def vectorizedSum(self, V,V_2):
        start = time.time()
        Z = np.zeros(self.f*self.c)
        for i in range (self.c*self.f):
            Z[i] = V[i] + V_2[i]
        end = time.time()
        print("Total vectorized matrix sum time: ", (end-start)*1000, "ms")

    def vectorizedSumNumpy(self, V,V_2):
        start = time.time()
        Z = V + V_2
        end = time.time()
        #print("Total vectorized matrix Numpy sum time: ", (end-start)*1000, "ms")
    def plotSpeedUp(self, x, y, lab):
      plt.title("SpeedUp")
      plt.xlabel("N, the dimension of the matrix is given by NxN")
      plt.ylabel("Execution Time")
      plt.plot(x,y, label=lab)
      plt.legend(loc="best")

    def saveFigure(self, title, quality):
        plt.savefig(title, dpi=quality, bbox_inches='tight')
######################################RESTAS##################################################
    def substraction(self):
        # Definir una matriz de las mismas dimensiones de A
        # Verificar que las matrices sean iguales
        start = time.time()
        if (len(self.M) == len(self.M_2) and len(self.M[0] == len(self.M_2[0]))):
            C = np.zeros_like(self.M);
            for i in range(len(self.M)):
                for j in range(len(self.M[0])):
                    C[i][j] = self.M[i][j] - self.M_2[i][j]
        end = time.time()
        #print("Total matrix subtraction time: ", (end-start)*1000, "ms")
        return ((end-start)*1000)
    def vectorizedSub(self, V,V_2):
        start = time.time()
        Z = np.zeros(self.f*self.c)
        for i in range (self.c*self.f):
            Z[i] = V[i] - V_2[i]
        end = time.time()
        #print("Total vectorized matrix subtraction time: ", (end-start)*1000, "ms")
        return ((end-start)*1000)
######################################Multiplicaciones#########################################
    def multiplicaciónMatrices(self):
        start = time.time()
        if(len(self.M_2[0]) == len(self.M)):
            z = np.zeros_like(self.M)
            for i in range(len(self.M_2)):
              for j in range(len(self.M[0])):
                for k in range(len(self.M)):
                  z[i][j]+= self.M[i][k]*self.M_2[k][j]
        else: 
            print("No es posible realizar la multiplicación matricial")
        end = time.time()
        time_mult_convencional = (end-start)*1000
        return z, time_mult_convencional
    def vectorizedMult(self, V,V_2):
      start = time.time()
      if(len(V)==len(V_2)):
        z = np.zeros(len(V))
        a=0
        b=0
        for i in range(len(V_2)):
          for j in range(self.c):
            z[i] += V[j+a]*V_2[b+j*self.c]
            if((j+1)%self.c == 0):
              b+=1
          if((i+1)%self.c==0):
            a+=self.c
            b=0
      else:
        print("No es posible realizar la multiplicación")
      end = time.time()
      time_mult_vector = (end-start)*1000
      return z, time_mult_vector
#####################DIVISIÓN#############################
    def division(self, M,N):
      start = time.time()
      z = np.zeros_like(M)
      for i in range(len(M)):
          for j in range(len(M[0])):
            if(N[i][j] == 0):
              z[i][j] = np.inf
            else:
              z[i][j] = M[i][j] / N[i][j]
      end = time.time()
      return z, ((end-start)*1000)
#####################TRANSPUESTA###########################################################
    def transpuesta(self, M):
      start = time.time()
      z = np.zeros_like(M)
      for i in range(len(M)):
        for j in range(len(M[0])):
          z[i][j]=M[j][i]
      end = time.time()
      return z, ((end-start)*1000)


"""
    Estructura para representar un elemento disperso
"""
class SparseStructure:
    def __init__(self, f, c, value):
        self.fila = f
        self.col = c
        self.value = value
##################################################################################################
#########################OPERACIONES CON MATRICES DISPERSAS(MISMA MATRIZ)######################
class SparseMatrix:
    """
        Suma de una matriz dispersa
    """
    def suma(self, M):
        z = list()
        start = time.time()
        # Misma matriz
        for i in range(len(M)):
            z.append(M[i].value + M[i].value)
        end = time.time()
        print("Tiempo total suma dispersa: ", (end-start)*1000, "ms")
        return z, (end-start)*1000
    """
        Resta de una matriz dispersa
    """
    def resta(self, M):
        z = list()
        start = time.time()
        # Misma matriz
        for i in range(len(M)):
            z.append(M[i].value - M[i].value)      
        end = time.time()
        print("Tiempo total resta dispersa: ", (end-start)*1000, "ms")
        return z, (end-start)*1000
    """
        Imprimir matriz dispersa
    """
    def printSparseMatrix(self,vectorSparse):
        #Impresión sólo de elementos !=0
        for i in vectorSparse:
            #Acceso eficiente
            print(i.fila, i.col ,i.value)
            # Acceder a la matriz original (No eficiente)
            # print("Valor Matriz: ", M[i.fila][i.col])
    """
        Calcular la transpuesta de una matriz dispersa
    """
    def transposeSparseMatrix(self, vectorSparse):
        start = time.time()
        transp = list()
        for i in vectorSparse:
            tmp = i.fila
            i.fila = i.col
            i.col = tmp
            transp.append(i)
        end = time.time()
        return transp, ((end-start)*1000)
    def multiplicacion(self, M):
        z = list()
        start = time.time()
        for i in range(len(M)):
            z.append(M[i].value * M[i].value)
        end = time.time()
        return z, ((end-start)*1000)
##################################################################################################
####################OPERACIONES CON MATRICES DISPERSAS DIFERENTES USANDO DICCIONARIOS#############
class SparseMatrixDict:
    def printMatrix(self, dict):
        for i in range(len(dict.keys())):
            for j in range(len(dict.values())):
                print("Elements of dict: ", dict[i], dict[i][j])

    def initStructureDict(self, M):
        dictSparseM = dict()
        r=0
        columns = dict()
        for i in range(len(M)):
          first  = False
          for j in range(len(M[0])):
              if(M[i][j] != 0): 
                  if (first == False):
                      dictSparseM[i] = dict()
                      first = True
                  dictSparseM[i][j] = M[i][j]
                  columns[r] = str(j) 
                  r+=1
        return dictSparseM,columns

########################SUMA USANDO DICCIONARIOS#########################################
    def suma(self, M_1, N_1,columns_M_1, columns_N_1):
      start = time.time()
      Z = copy.deepcopy(M_1)
      #print(columns_M_1)
      #r = 0
      N_1 = copy.deepcopy(N_1)
      for i in N_1:
        #largo = len(Z[i])
        if(i in Z):
          for j in N_1[i]:
            #if(Z[i][int(columns_M_1[r])]):
            #Z[i][int(columns_M_1[r])] +=temp 
            if(j in Z[i]):
              Z[i][j]+= N_1[i][j]
              continue
            else:
              Z[i][j]=N_1[i][j]
            #print(Z[i][int(columns_M_1[r])])
        else:
          Z[i]=N_1[i]
      #print(Z)
            #r+=1
      end = time.time()
      return ((end-start)*1000)

########################RESTA USANDO DICCIONARIOS#########################################
    def resta(self, M_1, N_1):
      start = time.time()
      Z = copy.deepcopy(M_1)
      #print(columns_M_1)
      #r = 0
      N_1 = copy.deepcopy(N_1)
      for i in N_1:
        #largo = len(Z[i])
        if(i in Z):
          for j in N_1[i]:
            #if(Z[i][int(columns_M_1[r])]):
            #Z[i][int(columns_M_1[r])] +=temp 
            if(j in Z[i]):
              Z[i][j]-= N_1[i][j]
              continue
            else:
              Z[i][j]=N_1[i][j]
            #print(Z[i][int(columns_M_1[r])])
        else:
          Z[i]=N_1[i]
      end = time.time()
      #print(Z)
      return ((end-start)*1000)
########################DIVISIÓN USANDO DICCIONARIOS#########################################
    def division(self, M_1, N_1):
      start = time.time()
      Z = copy.deepcopy(M_1)
      N_1 = copy.deepcopy(N_1)
      for i in N_1:
        if(i in Z):
          for j in N_1[i]:
            if(j in Z[i] and N_1[i][j] != 0):#exceptuamos división por 0
              Z[i][j] = Z[i][j]/ N_1[i][j]
            else:
              Z[i][j] = 0 #si borramos esta asignación nos aseguramos de eliminar aún más ceros
        else:
          Z[i]= 0#si borramos esta asignación nos aseguramos de eliminar aún más ceros
      for i in M_1:
        if(i in N_1):
          for j in M_1[i]:
            if(j in N_1[i]):
              break
            else:
              Z[i][j]=np.inf
        else:
          Z[i]=np.inf
      end = time.time()
      #print(Z)
      return ((end-start)*1000)

def initMatrix(f, c, M):
    elements = int ((f * c) * 0.1)
    cont = 0
    for i in range(len(M)):
        for j in range(len(M[0])):
            if(random.random() >= 0.75 ):
                if (cont >= elements):
                    break;
                M[i][j] = random.randint(1,10);
                cont += 1
    return M
def main():
    # Inicializar variables
    f = 10
    indice = 0
    rango = 10
    f_vec =np.zeros(rango)
    timesSuma_convencional = np.zeros(rango)
    timesSuma_sparse = np.zeros(rango)
    SpeedUpSuma = np.zeros(rango)

    timesResta_convencional = np.zeros(rango)
    timesResta_sparse = np.zeros(rango)
    SpeedUpResta = np.zeros(rango)

    timesMult_convencional = np.zeros(rango)
    timesMult_sparse = np.zeros(rango)
    SpeedUpMult = np.zeros(rango)

    timesDiv_convencional = np.zeros(rango)
    timesDiv_sparse = np.zeros(rango)
    SpeedUpDiv = np.zeros(rango)

    timesTrans_convencional = np.zeros(rango)
    timesTrans_sparse = np.zeros(rango)
    SpeedUpTrans = np.zeros(rango)

    while(f<=100):
      c = f
      f_vec[indice] = f
      # Definición de matrices
      M = np.zeros((f, c), dtype=np.float)
      N = np.zeros((f, c), dtype=np.float)

      vectorSparseM = list() # Inicializando una lista vacía 
      vectorSparseN = list()
      # inicializar de forma aleatoria el 10 -15% de la matriz
      M = initMatrix(f, c, M)
      N = initMatrix(f, c, N)
      #N = initMatrix(f, c, N)

      # inicializar estructura dispersa
      for i in range(len(M)):
          for j in range(len(M[0])):
              if(M[i][j] != 0): 
                  vectorSparseM.append(SparseStructure(i,j, M[i][j])); # Se almacena un objeto en cada posición de la lista
              if(N[i][j]!=0):
                  vectorSparseN.append(SparseStructure(i,j,N[i][j]));
      
      """print("Matrices originales")
      print (M)
      print (N)"""

      """print("Matrices dispersas en forma de vectores")
      for i in vectorSparseM:
        print(i.fila,i.col,i.value)
      print("\n")
      for i in vectorSparseN:
        print(i.fila, i.col, i.value)"""

      ########################## Operaciones convencionales#######################3
      objMat = Matrix(f, c, M, N)
      sumConv, timesSuma_convencional[indice] = objMat.suma()
      timesResta_convencional[indice] = objMat.substraction()
      multConv, timesMult_convencional[indice] = objMat.multiplicaciónMatrices()
      divConv, timesDiv_convencional[indice] = objMat.division(M,N)
      transpConv, timesTrans_convencional[indice] = objMat.transpuesta(M)

  ############################Operaciones Dispersas######################################3
      objSparse = SparseMatrix()
      objSparseMatDic = SparseMatrixDict()
      M_dict, columns_M_1 = objSparseMatDic.initStructureDict(M)
      N_dict, columns_N_1 = objSparseMatDic.initStructureDict(N)
      """sumSparse, timeSumSparse =  objSparse.suma(vectorSparseM)
      print("SpeedUp: ", timeSumConv/timeSumSparse)"""

      #print(M_dict.items())
      #print(M_dict.keys(), M_dict.values())
      #print(N_dict.keys(), N_dict.values())

      timesSuma_sparse[indice] = objSparseMatDic.suma(M_dict,N_dict, columns_M_1, columns_N_1)
      timesResta_sparse[indice] = objSparseMatDic.resta(M_dict, N_dict)

      timesDiv_sparse[indice] = objSparseMatDic.division(M_dict, N_dict)
      transp, timesTrans_sparse[indice] = objSparse.transposeSparseMatrix(vectorSparseM)
      multSparse, timesMult_sparse[indice] = objSparse.multiplicacion(vectorSparseM)
    
      SpeedUpSuma[indice] = timesSuma_convencional[indice]/timesSuma_sparse[indice]
      SpeedUpResta[indice]=timesResta_convencional[indice]/timesResta_sparse[indice]
      SpeedUpMult[indice] =  timesMult_convencional[indice]/timesMult_sparse[indice] 
      SpeedUpDiv[indice] = timesDiv_convencional[indice]/timesDiv_sparse[indice]
      SpeedUpTrans[indice]=timesTrans_convencional[indice]/timesTrans_sparse[indice]
      f+=10
      indice+=1
    print("SpeedUp Suma: \n", SpeedUpSuma)
    print("SpeedUp Resta: \n",SpeedUpResta)
    print("SpeedUp Multiplicación: \n",SpeedUpMult)
    print("SpeedUp División: \n",SpeedUpDiv)
    print("SpeedUp Transpuesta: \n",SpeedUpTrans)




    objMat.plotSpeedUp(f_vec, SpeedUpSuma, "SpeedUp Suma")
    #objMat.plotSpeedUp(f_vec, SpeedUpResta, "''Resta")
    #objMat.plotSpeedUp(f_vec, SpeedUpMult, "''Mult")
    #objMat.plotSpeedUp(f_vec, SpeedUpDiv, "''Div")
    #objMat.plotSpeedUp(f_vec, SpeedUpTrans, "SpeedUp Transp")

    objMat.saveFigure("SparseTransp", 300)
    
if __name__ == "__main__":
    main()